---
title: Sub-steps
description: Breaking down complex steps into smaller operations
---

**Sub-steps** allow you to break down complex steps into smaller, trackable operations within a parent step. They provide fine-grained visibility into complex operations while maintaining the overall step context.

### When to Use Sub-steps

- **Complex operations** - Multiple distinct actions within one step
- **Parallel execution** - Running multiple operations concurrently
- **Debugging visibility** - Need to see intermediate progress
- **Performance analysis** - Identify bottlenecks within steps

### Sub-step Properties

- **Parent step** - Associated with a main step
- **Unique name** - Within the parent step context
- **Independent status** - Can succeed or fail independently
- **Timestamps** - Track execution timing
- **Context data** - Specific to the sub-step operation

### Sub-step vs Step

<table className="w-full">
  <thead>
    <tr className="border-b border-gray-300">
      <th className="text-left font-semibold py-2 pr-4">Feature</th>
      <th className="text-left font-semibold py-2 pr-4">Step</th>
      <th className="text-left font-semibold py-2">Sub-step</th>
    </tr>
  </thead>
  <tbody>
    <tr className="border-b border-gray-200">
      <td className="py-2 pr-4">Scope</td>
      <td className="py-2 pr-4">Thread-level</td>
      <td className="py-2">Within a step</td>
    </tr>
    <tr className="border-b border-gray-200">
      <td className="py-2 pr-4">Validation</td>
      <td className="py-2 pr-4">Contract rules</td>
      <td className="py-2">No validation</td>
    </tr>
    <tr>
      <td className="py-2 pr-4">Notifications</td>
      <td className="py-2 pr-4">Can trigger events</td>
      <td className="py-2">No events</td>
    </tr>
  </tbody>
</table>

### Example

<Tabs>
<Tab title="Node.js">
```javascript
// Track granular operations within a step
const paymentStep = thread.step('payment_processed');

try {
  paymentStep.subStep('validate_card', { cardType: 'visa' }, 'success');
  paymentStep.subStep('check_fraud', { fraudScore: 0.15 }, 'success');
  paymentStep.subStep('authorize_payment', { authCode: 'AUTH-123' }, 'success');
  
  await paymentStep
    .addContext({ totalAmount: 299.99 })
    .success();
    
} catch (error) {
  paymentStep.subStep('error_handler', { error: error.message }, 'failed');
  await paymentStep.failed({ message: 'Payment failed' });
}
```
</Tab>
<Tab title="Go">
```go
// Track granular operations within a step
paymentStep := thread.Step("payment_processed")

err := processPayment()
if err != nil {
    paymentStep.SubStep("error_handler", map[string]any{"error": err.Error()}, "failed")
    _, stepErr := paymentStep.Failed(ctx, map[string]any{"message": "Payment failed"})
    if stepErr != nil {
        log.Fatal(stepErr)
    }
    return
}

paymentStep.SubStep("validate_card", map[string]any{"cardType": "visa"}, "success")
paymentStep.SubStep("check_fraud", map[string]any{"fraudScore": 0.15}, "success")
paymentStep.SubStep("authorize_payment", map[string]any{"authCode": "AUTH-123"}, "success")

_, err = paymentStep.
    AddContext(map[string]any{"totalAmount": 299.99}).
    Success(ctx)
if err != nil {
    log.Fatal(err)
}
```
</Tab>
</Tabs>

## Best Practices

- **Logical grouping** - Sub-steps should be related to parent step
- **Don't overuse** - Not every operation needs a sub-step
- **Clear naming** - Describe the specific sub-operation
- **Consistent patterns** - Use similar sub-step structures across steps

